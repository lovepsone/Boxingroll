<!DOCTYPE html>
<html>
	
	<head>
	
		<meta charset = "utf8"></meta>
	
		<title>Three.js pickObject example</title>
	
		<style>
			
			body {
				margin : 0;
			}
			
			canvas {
				width : 100%; 
				height : 100%;
			}
			
			#panel {
				position : absolute;
				left : 50px;
				top : 50px;
				color : #FFFFFF;
				padding : 5px;
				outline : rgba(128, 128, 255, 0.5) solid 2px;
				background-color : rgba(0, 0, 128, 0.5);
			}
			
			#game {
				position : absolute;
				left : 100px;
				top : 50px;
			}
			
		</style>
		
	</head>
	
	<body>
		<p>Немного текста чтобы сдвинуть канву с (0,0) </p>
		
		<div id = "game">
			<div id = "panel">
				<p id = "mouseX">mouse x : </p>
				<p id = "mouseY">mouse y : </p>
			</div>
		</div>
	
		<script src = "js/three.min.js"></script>
	
		<script>
		
			var mouseX = 0.0;
			
			var mouseY = 0.0;
			
			var renderer = new THREE.WebGLRenderer();
//			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setSize(1000, 1200);
			document.getElementById("game").appendChild(renderer.domElement);

			var scene = new THREE.Scene();
	
			var camera = new THREE.PerspectiveCamera(45, renderer.domElement.offsetWidth / renderer.domElement.offsetHeight, 0.1, 100);
			camera.position.set(0, 5, 5);
			camera.lookAt(new THREE.Vector3(0, -1, -1));

			var raycaster = new THREE.Raycaster();

			renderer.domElement.addEventListener("click", function (event) {
				event.preventDefault();
				// Определяем положение мыши относительно элемента
				var br = this.getBoundingClientRect();
				mouseX = (event.clientX - br.left) / renderer.domElement.offsetWidth * 2 - 1;
				mouseY = 1 - (event.clientY - br.top) / renderer.domElement.offsetHeight * 2;
				document.getElementById("mouseX").innerHTML = "mouse x : " + mouseX.toFixed(2);
				document.getElementById("mouseY").innerHTML = "mouse y : " + mouseY.toFixed(2);

				var vector = new THREE.Vector3(mouseX, mouseY, 0).unproject(camera);
				raycaster.set(camera.position, vector.sub( camera.position ).normalize());
				var intersects = raycaster.intersectObject(scene, true);
				if (intersects.length > 0) {
					alert(intersects[0].object.name);
				}
			});
			
			renderer.domElement.addEventListener("mousemove", function (event) {
				event.preventDefault();
				// Определяем положение мыши относительно элемента
				var br = this.getBoundingClientRect();
				mouseX = (event.clientX - br.left) / renderer.domElement.offsetWidth * 2 - 1;
				mouseY = 1 - (event.clientY - br.top) / renderer.domElement.offsetHeight * 2;
				document.getElementById("mouseX").innerHTML = "mouse x : " + mouseX.toFixed(2);
				document.getElementById("mouseY").innerHTML = "mouse y : " + mouseY.toFixed(2);
			});

/*			
			window.addEventListener("resize", function (event) {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
*/
			
			var boxGeometry = new THREE.BoxGeometry(1, 1, 1);
			var boxMaterial = new THREE.MeshBasicMaterial({color : 0x0000FF});
			var boxMeshCenter = new THREE.Mesh(boxGeometry, boxMaterial);
			boxMeshCenter.name = "boxMeshCenter";
			scene.add(boxMeshCenter);
			
			var boxMeshLeft = new THREE.Mesh(boxGeometry, boxMaterial);
			boxMeshLeft.position.set(-2, 0, 0);
			boxMeshLeft.name = "boxMeshLeft";
			scene.add(boxMeshLeft);

			var boxMeshRight = new THREE.Mesh(boxGeometry, boxMaterial);
			boxMeshRight.position.set(2, 0, 0);
			boxMeshRight.name = "boxMeshRight";
			scene.add(boxMeshRight);

			function renderScene() {
				requestAnimationFrame(renderScene);
				boxMeshCenter.rotation.y += 0.01;
				renderer.render(scene, camera);
			}
			
			renderScene();
			
		</script>
		
	</body>
	
</html>
